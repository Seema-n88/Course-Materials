Task processing with Teachnet
================================

"Package Contents"
--------------

teachnet.jar	- Executable JAR file with GUI front-end
lib/		- libraries needed by Teachnet
templates/	- Templates for the task processing
doc/		- documentation ( inter alia this file)




***************************************************************************
*** This file has been automatically generated by google translator and ***
*** has been manually corrected at some parts. Please keep that in mind ***
*** when reading this file.                                             ***
***************************************************************************







Quick Start
----------

First, a brief summary of the use of Teachnet which is
used to simulate algorithms in the course Distributed Algorithms.

Step 1 - generate Java file with a new algorithm :

In the directory " templates " is an example.

It is not necessary the files with " javac " to translate
although this can be done for more exact fault analysis.


Step 2 - Start Teachnet GUI:

After editing the source files, this should by GUI frontend
be controlled.

This is the first Teachnet GUI to start , this is done by means of the
command:

java-jar teachnet.jar


Step 3 - Load templates sources :

After starting the GUI , first need the edited source files
translated and the classes are loaded .

This is done in the " classpath " menu with the menu item " Compile and load classes" .
In the resulting file selection dialog is only the folder
select that contains the Java files , and confirm with "Open" or " Open" .

For errors voerst just a simple dialog that appears more accurate troubleshooting
So compile only with myself .

Note:
Who has the files already compiled itself can also the start of the
Teachnet GUI to add to the classpath , then omitted step 3:

java-cp <path to Klassen> : teachnet.jar teachnet / view / TeachnetFrame


Step 4 - Load configuration :

Next, a configuration for the simulation run is selected.
These are specified in files ( documentation in the "doc / config example.txt " ) .

One of the most suitable for the task configuration must now in "Simulation" menu
the menu item "Load config" will be loaded.

There should be a now a graph will appear . The GUI tries the graph clearly
to arrange the nodes but by using the left mouse button
be moved.


Step 5 - Select View:

There is the "View" menu to select different views . this
can be selected for specific algorithm processes to better recognize .

The provided example shows what is currently the " generic view "
is possible.


Step 6 - Perform simulation :

The buttons on the toolbar , the simulation can now be controlled :

(from left to right)

1 Reset with new random (rewind icon)

Rewinds back to the beginning of the simulation and generates a new
Seeds , which causes that the simulation does not
exactly repeated.

2 Reset with the same random number generator ( Track Back button )

Rewinds the simulation to the top and keeps the random
at what causes the simulation behaves exactly the same again
as in the passage before.

3 Start / pause (play / pause icon )

Starts or Pauses ( icon changes ) simulation. If the algorithm
terminated ( no more news on the way) runs the simulation until
End and then pauses automatically .


Implementation of algorithms
-------------------------------

As the basis for all algorithms in the class is Teachnet
teachnet.algorithm.BasicAlgorithm to be derived .

The only requirement for the derived class is that these are only a
Default constructor ( without parameters) can have .


Methods that must be implemented :


void initiate()

This method is used to start the algorithm and can be on one or
a plurality of nodes are running . When and where it is performed, by
actual configuration file specified.


void receive(int interf, Object message)

This method is executed when entering into a message and forms the core
the simulation model. Within this method , the algorithm may incoming
Analyze messages and respond by sending of messages ( see below).
The simulation model assumes that the execution time of this method
(and all other methods ) is 0 , so it should in no case
e.g. be serviced with Thread.sleep .
The real execution time of all methods can of course be arbitrarily long (eg
However, for complex calculations , the simulation pauses at each method call
until it terminates .


Methods that can be overridden :


void setup(Map<String, Object> config)

Since the class can not receive parameters via its constructor may need
existing algorithm parameters are passed to the method.
As these parameters are called , and what values ​​they may have about the configuration file
be defined.
In this method, nor may NOT messages are sent .
It is called once before the beginning of the simulation for each node.
If this method is not overridden (because no parameters are required)
used an empty implementation .


void timeout(Object message)

This class serves as callback method for timeouts (see below) . If no timeout
it must not be overwritten be used.


Methods provided by BasicAlgorithm available:


int checkInterfaces()

This method gives the number of interfaces of the node on which the algorithm
runs out . The interfaces are numbered from 0 to n-1, where n is the return value of
This method is .


void send(int interf, Object message)

This method is the only way in the simulation model used
to communicate with other nodes.
It is a message ( actual class any ) on the specified interface
sent. The value of the interface should move in the values ​​obtained by
be specified check interfaces ( See above ) .
Depending on the network topology reached this message from node 0 (no other node
connected via this interface ) to n nodes ( n other nodes with this
Interface connected ) .
IMPORTANT : There are no requirements on the class of the object sent
(in particular, it can not be serialized or cloned) MUST be sent the
Object after the ship are considered invariant , in particular
the object should not be modified and resent.
The sending of a message on all interfaces might look like this :

    for (int i = 0; i < checkInterfaces(); i++) {
        // IMPORTANT: Always send a NEW message
        send(i, new MyMessage());
    }


void setTimeout(double time , Object message)

This may for example be simulated on an event waiting . this method
ensures that after the specified timeout period, the method with the value
message is called as a parameter.


Several layers of algorithms
---------------------------------


Teachnet supports the simulation of several layers of algorithms
(Protocol layers ) . Serves this purpose , the class teachnet.algorithm.LayerAlgorithm ,
this is how to use and offers the following teachnet.algorithm.BasicAlgorithm
extensions:


Methods that must be implemented:


void forward(int interf, Object message)

This method is analogous to and receive calls when the next
overlying layer calls sent .


Methods provided by BasicAlgorithm available:


void handle(int interf, Object message)

This method is analog and is used to send messages to the
further up to send layer. Here, in the other layer
receive calls .


This behavior is transparent to the layers. A layer of " white " is not so
whether the call is routed by sending directly to the interface of the node
or whether the method handle an underlying layer below is called.
The same applies the other way - can receive a call directly from the node
made or done by the method forward another layer.

The top layer should therefore always of the class teachnet.algorithm.BasicAlgorithm
be derived (client layer) .

A layer only news " loop through " might look like this:

	@Override
	public void forward(int interf, Object message) {
		send(interf, message);
	}

	@Override
	public void receive(int interf, Object message) {
		handle(interf, message);
	}


Routing algorithms with
-----------------------


As a last resort offers Teachnet still a small extension that with
teachnet.algorithm.RoutingAlgorithm class is realized.
This behaves like teachnet.algorithm.LayerAlgorithm and requires additional
which implement a method:


int getInterfaces()

Is called when the next overlying layer interfaces calls and check
used for the upper layer as a result .
It is now possible , the number of interfaces is visible to the upper layer
are changing ( more or less ) .
NOTE : Since it is assumed that the interface of 0 to n- 1 (n is the
Result of check interfaces) are numbered , this must be respected.

A layer could hide the first interface ( 0) look like
( works only with 1 + interfaces) :

	@Override
	public int getInterfaces() {
		return checkInterfaces() - 1;
	}
    
	@Override
	public void forward(int interf, Object message) {
		send(interf + 1, message);
	}

